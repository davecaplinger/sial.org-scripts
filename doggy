#!/usr/bin/perl
#
# Markov model of dog days. Consider instead: http://hailo.org/

use strict;
use warnings;
use feature qw(say);

my %Dog_Days = (
  kennel => { door  => 0.5, gate1 => 0.5 },
  door   => { tree  => 1 },
  gate1  => { tree  => 1 },
  gate2  => { loops => 1 },
  tree   => { tree  => 0.9, loops => 0.1 },
  loops => { loops => 0.83, gate2 => 0.16, kennel => 0.1 },
);
cummulate( \%Dog_Days );

my $current_state = 'kennel';
do {
  say $current_state;
  if ( !exists $Dog_Days{$current_state} ) {
    warn "notice: aborting as no such node '$current_state'\n";
    $current_state = 'kennel';
  } else {
    $current_state = pick( $Dog_Days{$current_state} );
  }
} until $current_state eq 'kennel';

say $current_state;
exit 0;

# Need weighted odds to figure out which choice is appropriate. Carry
# along original odds to make adjusting the weightings easier (update
# original odds, then redo the weighting from those values).
sub cummulate {
  my ($decisions) = @_;
  for my $node ( keys %$decisions ) {
    my $sum = 0;
    for my $v ( values %{ $decisions->{$node} } ) {
      if ( $v < 0 ) {
        warn "warning: node '$node' adjusting negative value to zero\n";
        $v = 0;
      }
      $sum += $v;
    }
    die "error: node '$node' lacks choices of value\n" if $sum == 0;

    my $cumm = 0;
    my @odds;
    for my $k ( keys %{ $decisions->{$node} } ) {
      $cumm += $decisions->{$node}->{$k} / $sum;
      unshift @odds, [ $cumm, $k, $decisions->{$node}->{$k} ];
    }
    $decisions->{$node} = \@odds;
  }
}

sub pick {
  my ($odds) = @_;
  my $rand = rand;
  my $choice;
  for my $i (@$odds) { $choice = $i->[1] if $i->[0] >= $rand }
  return $choice;
}
