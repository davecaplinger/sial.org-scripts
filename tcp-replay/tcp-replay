#!/usr/bin/perl
#
# Simplistic TCP traffic replay: replays TCP sessions recorded by
# tcpdump by sending the previous client request data payloads to the
# destination via a new TCP connection. Does not reproduce sequence
# numbers, handle anything coming back from the server, nor emulate the
# timing of the previous TCP stream.
#
# Handy if one (hypothetically) has a LDAP server that only crashes when
# exposed to production traffic, but never to test traffic, nor the same
# requests logged in production replayed via ldapsearch or Net::LDAP.
#
# Script will be memory intensive to the tune of the number of
# connections in the tcpdump file.
#
# Collect the input data via something like:
#   tcpdump -vv -c 100000 -s 0 -w traffic-tcpdump port 389
#
# Then run:
#   tcp-replay -s SERVERIP -d REPLAYSERVERIP -p 389
#
# Where SERVERIP is the address the desired TCP traffic is going to, and
# REPLAYSERVERIP the test server the TCP payloads should be resent to.
#
# The author disclaims all copyrights and releases this script into the
# public domain.

use strict;
use warnings;

my ( $SRC_IP, $DST_IP, $PORT );

use Getopt::Long qw(GetOptions);
GetOptions(
  "src|s=s"  => \$SRC_IP,
  "dst|d=s"  => \$DST_IP,
  "port|p=s" => \$PORT
);

if ( !defined $PORT and $DST_IP =~ m/^(.*?):(\d+)$/ ) {
  $DST_IP = $1;
  $PORT   = $2;
}

my $file = shift;
if ( !defined $file
  or !defined $SRC_IP
  or !defined $DST_IP
  or !defined $PORT ) {
  die "Usage: $0 -s src-ip -d dst-ip -p port traffic-tcpdump\n";
}

use IO::Socket::INET;
use Net::Frame::Dump::Offline;
use Net::Frame::Simple;
use Net::Frame::Layer::IPv4 qw(:consts);
use Net::Frame::Layer::TCP qw(:consts);
use Time::HiRes qw(sleep);

########################################################################
#
# COLLECTION
#
# Build stash of previous full TCP connections. Sessions started prior
# to the tcpdump starting will be ignored.

my %seen;

my $oDump = Net::Frame::Dump::Offline->new( file => $file );
$oDump->start;

my $count = 0;
DGRAM: while ( my $h = $oDump->next ) {
  my $f = Net::Frame::Simple->new(
    raw        => $h->{raw},
    firstLayer => $h->{firstLayer},
    timestamp  => $h->{timestamp},
  );

  my $orig_ipv4;

  for my $l ( $f->layers ) {
    if ( ref $l eq 'Net::Frame::Layer::IPv4' ) {
      next DGRAM if $l->dst ne $SRC_IP;
      $orig_ipv4 = $l;

    } elsif ( ref $l eq 'Net::Frame::Layer::TCP' ) {
      if ( $l->flags & NF_TCP_FLAGS_SYN ) {
        push @{ $seen{ $orig_ipv4->src . $l->src } },
          { ip => $orig_ipv4, tcp => $l };
      } else {
        if ( exists $seen{ $orig_ipv4->src . $l->src } ) {
          push @{ $seen{ $orig_ipv4->src . $l->src } },
            { ip => $orig_ipv4, tcp => $l };
        }
      }
    }
  }
}
$oDump->stop;

########################################################################
#
# REPLAY
#
# Simplistic replay from %seen stash: sends previous payloads over a new
# TCP connection. Disregards server responses, random delay before
# sending next datagram.

for my $conn ( values %seen ) {
  my $io =
    IO::Socket::INET->new( PeerAddr => "$DST_IP:$PORT", Proto => "tcp" );

  for my $frame (@$conn) {
    if ( defined $frame->{tcp}->payload
      and length $frame->{tcp}->payload > 0 ) {

      my $epoch = time();
      print "$epoch ", $frame->{ip}->src, ":", $frame->{tcp}->src,
        " ipv4-id ",
        $frame->{ip}->id, " tcp-seq ", $frame->{tcp}->seq, "\n";

      $io->send( $frame->{tcp}->payload );
      # TODO could replicate the timestamps somehow, but that's more work...
      sleep 0.1 + rand;
    }
  }

  # Be a good network citizen (otherwise may see RST related logs on
  # the server)
  $io->shutdown(2);
  $io->close();

  #sleep 3; # spacer to try to isolate if there is a specific Packet Of Death
}
