#!/usr/bin/perl
#
# Musical V/V utility, for arbitrary "chord X relative to Y as tonic in
# key Z" type calculations (V/V are called "applied dominants" though
# other scale degrees can be used, e.g. the phrase with a subphrase
# relative to IV "I IV/IV V/IV IV V I").
#
# Input format based somewhat upon
# https://en.wikipedia.org/wiki/Roman_numeral_analysis and other musical
# sources, with some tweaks for Unix command line input needs.

use strict;
use warnings;
use Carp;
use Getopt::Long qw/GetOptions/;
use List::Util qw/sum/;
use Text::Roman qw/roman2int/;

# Leading sharp/flats adjust the tonic up or down (might also support
# doublesharp or doubleflat, but those get tricky depending on the
# underlying note).
my $FLAT_CHARS      = 'b\x{266D}';
my $SHARP_CHARS     = '#\x{266F}';
my $ROMAN_PREFIX_RE = qr/[$FLAT_CHARS$SHARP_CHARS]/;
# Upper vs. lower case indicates major vs. minor quality of the 3rd
my $ROMAN_NUMERAL_RE = qr/III|iii|VII|vii|II|ii|IV|iv|VI|vi|I|i|V|v/;
# Whether to aug or dim chord, and then the chord factor (probably will
# ignore inversion numbers e.g. 2 6 64 and so forth for now, as those
# come from verticals of figured bass). (KLUGE ** is for "double dim")
my $ROMAN_SUFFIX_RE = qr/[+*]?[*]?\d*/;

# Standard tonal limits on scale degrees and non-repetition of triad
# pitches; adjust these if using some other scale system.
my $MAX_SCALE_DEGREE = 7;
# Western system of 7 scale degrees allows for at most a 13th chord
# before repeats; the following generalizes to arbitrary degrees.
my $MAX_CHORD_FACTOR =
  ( $MAX_SCALE_DEGREE % 2 == 0 ? $MAX_SCALE_DEGREE : $MAX_SCALE_DEGREE * 2 ) -
  1;
my $DEFAULT_CHORD_FACTOR = 5;    # a 5th

my $DEG_IN_SCALE = 12;

my $Mode = 'major';
my %Modes = (
  ionian     => [qw(2 2 1 2 2 2 1)],
  lydian     => [qw(2 2 2 1 2 2 1)],
  mixolydian => [qw(2 2 1 2 2 1 2)],
  dorian     => [qw(2 1 2 2 2 1 2)],
  amdorian   => [qw(2 1 2 1 2 2 2)],
  aeolian    => [qw(2 1 2 2 1 2 2)],
  mminor     => [qw(2 1 2 2 2 2 1)],
  hminor     => [qw(2 1 2 2 1 3 1)],
  hunminor   => [qw(2 1 3 2 1 3 1)],
  phrygian   => [qw(1 2 2 2 1 2 2)],
  locrian    => [qw(1 2 2 1 2 2 2)],
);
$Modes{'major'} = $Modes{'ionian'};
$Modes{'minor'} = $Modes{'aeolian'};

my $Transpose       = 0;

GetOptions(
  'minor'                  => \my $use_minor,
  'mode=s'                 => \$Mode,
  'transpose|t=i'          => \$Transpose,
) || die "error: could not parse options\n";

$Mode = 'minor' if $use_minor;
die "error: no such mode '$Mode'" unless exists $Modes{$Mode};

for my $vov_spec (@ARGV) {
  my @vovs = reverse split '/', $vov_spec;

  my ( $root_sd, $factor, $alterations ) = parse_roman_numeral( shift @vovs );
  my $sds = build_triad_degrees( $root_sd, $factor );
  my $pset = sd2ps( $sds, $alterations, $Modes{$Mode}, 0 );
  use Data::Dumper; warn Dumper $pset;

  for my $vov ( @vovs ) {
    my ( $sub_root_sd, $subfactor, $sub_alt) = parse_roman_numeral( $vov );
    my $subsds = build_triad_degrees( $sub_root_sd, $subfactor );
    my $subpset = sd2ps( $subsds, $sub_alt, $Modes{$Mode}, $pset->[0] );
    use Data::Dumper; warn Dumper $subpset;
  }
}

exit 0;

########################################################################
#
# SUBROUTINES

# Given root scale degree plus a chord factor, returns an array
# reference of scale degress of the chord elements up to the
# chord factor.
sub build_triad_degrees {
  my ( $root_sd, $factor ) = @_;
  if ( defined $factor ) {
    $factor =~ tr/0-9//cd;    # so can say "5th" or "7th" or the like
    if ( $factor < 1 or $factor > $MAX_CHORD_FACTOR or $factor % 2 == 0 ) {
      croak
        "factor must be odd number between 1 and $MAX_CHORD_FACTOR inclusive";
    }
  } else {
    $factor = $DEFAULT_CHORD_FACTOR;
  }

  if ( !defined $root_sd or $root_sd < 0 or $root_sd >= $MAX_SCALE_DEGREE ) {
    croak "root scale degree must be 0 to "
      . ( $MAX_SCALE_DEGREE - 1 )
      . " inclusive";
  }

  my @sds;
  # I blame too many slope equation videos & exercises on Khan Academy
  # for this code.
  for my $i ( 1 .. ( $factor * 0.5 + 0.5 ) ) {
    push @sds, ( $root_sd + 2 * $i - 2 ) % $MAX_SCALE_DEGREE;
  }

  return \@sds;
}

sub parse_roman_numeral {
  my ($numeral) = @_;
  my ( $pre, $roman, $suf ) =
    $numeral =~ m/^($ROMAN_PREFIX_RE)?($ROMAN_NUMERAL_RE)($ROMAN_SUFFIX_RE)?/;
  $pre //= '';
  $suf //= '';

  my %alterations;
  my $factor = $DEFAULT_CHORD_FACTOR;

  my $scale_degree = roman2int($roman) if $roman;
  if ( !$scale_degree ) {
    croak "could not parse '$numeral'";
  } else {
    $scale_degree--;    # base from 0..6 for ease of internal calcs

    if ( lc $roman eq $roman ) {
      $alterations{1} = -1;
    } else {
      $alterations{1} = 1;
    }
  }
  # sharpen or flatten the root (e.g. for bII or #IV chromatic alterations)
  if ( $pre =~ m/[$FLAT_CHARS]/ ) {
    $alterations{0} = -1;
  } elsif ( $pre =~ m/[$SHARP_CHARS]/ ) {
    $alterations{0} = 1;
  }
  # augment or diminish the 5th (or 7th with **)
  if ( $suf =~ m/[+]/ ) {
    $alterations{2} = 1;
  } elsif ( $suf =~ m/\*\*/ ) {
    $alterations{1} = -1;    # assumption of minor 3rd for double dim.
    $alterations{2} = -1;
    $alterations{3} = -1;
  } elsif ( $suf =~ m/\*/ ) {
    $alterations{1} = -1;    # assumption of minor 3rd for dim.
    $alterations{2} = -1;
  }
  # figure out factor of chord from optional trailing digits
  if ( $suf =~ m/(\d+)/ ) {
    my $digits = $1;
    if ( $digits <= $MAX_CHORD_FACTOR and $digits % 2 == 1 ) {
      $factor = $1;
    }
    # XXX support 6, 64 5th inversions, 65 43 2 (implied factor 7)
    # inversions here? - could also use letter form, e.g. V7b for
    # dominant 7th, first inversion (65)a. This would tweak the order of
    # pitches in an eventual pitch set created...
  }

  return $scale_degree, $factor, \%alterations;
}

sub sd2ps {
  my ( $sdset, $alterations, $scale_intervals, $transpose ) = @_;
  $alterations //= {};
  $transpose ||= 0;

  my @pset;
  for my $sd (@$sdset) {
    push @pset, $sd != 0 ? sum( @{$scale_intervals}[ 0 .. $sd - 1 ] ) : 0;
  }
  for my $i ( sort { $a <=> $b } keys %$alterations ) {
    croak "invalid alteration index '$i'" if $i < 0 or $i > $#pset;
    if ( $i > 0 ) {
      # KLUGE skip alteration if already applied by the scale in
      # question (e.g. don't flatten 3rd of "i" in c-minor as will
      # already be a minor 3rd). Better implementation might just deal
      # with major vs. minor 3rds, and stack those up?
      next if $alterations->{$i} == -1 and $pset[$i] - $pset[ $i - 1 ] == 3;
      next if $alterations->{$i} == 1  and $pset[$i] - $pset[ $i - 1 ] == 4;
    }
    $pset[$i] += $alterations->{$i};
  }

  for my $p (@pset) {
    $p += $transpose;
    $p %= $DEG_IN_SCALE;
  }
  return \@pset;
}

END {
  # Report problems when writing to stdout (perldoc perlopentut)
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
