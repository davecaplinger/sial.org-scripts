#!/usr/bin/perl
#
# Generate notes of a scale (a subset of the Western 12-tone chromatic
# system) from a specified starting note in a specified direction and so
# forth from other options. Default is The Major Scale, but that's easy
# to adjust:
#
#   $ scalemogrifier --intervals='c d ees f g aes bes' --flats fis
#
# Or to more exotic territory:
#
#   $ scalemogrifier --intervals='c cis dis e g' --length=12 f
#
# Or backwards:
#
#   $ scalemogrifier --dir=-1 --intervals='c cis dis e g' --length=12 f
#
# Or backwards with the interval order reversed:
#
#   $ scalemogrifier --rev --dir=-1 --intervals='c cis dis e g' --length=12 f
#
# Or just plain made up with raw pitch numbers:
#
#   $ scalemogrifier --intervals=1,2,3,4 --raw --len=24
#
# Or output not really a scale at all:
#
#   $ scalemogrifier --intervals=1,2,3,5,7 --dir=53 --relative --len=24
#
# Or even sequences, such as down a 4th and up a 5th:
#
#   $ scalemogrifier --intervals=-5,7 --len=24 c
#
# Practical application of the results to music theory or composition
# left as an exercise to the user. The output could be fed to `ly-fu --abs`
# for playback or incorporation into a lilypond document.
#
# Consider http://oeis.org/ to lookup or find interesting interval sets;
# for example, search for the major interval sequence for numeric
# sequences that contain it:
#
# http://oeis.org/search?q=2,2,1,2,2,2,1

use strict;
use warnings;

use Getopt::Long qw/GetOptions/;
use Text::Wrap qw/wrap/;

# Accepted note names to pitch number for user input
my %note2num = qw(c 0 cis 1 d 2 dis 3 e 4 f 5 fis 6 g 7 gis 8 a 9 ais 10 b 11
  ces 11 des 1 ees 3 fes 4 ges 6 aes 8 bes 10 eis 5 bis 0);

# Note names for program output
my %num2note = (
  'ly-sharp' =>
    {qw/0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b/},
  'ly-flat' =>
    {qw/0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b/},
);
my $num2note_flavor = 'ly-';

# Not The Scale, but to map back to That Other Scale.
my $DEG_IN_SCALE = 12;

my @scale_intervals = qw(2 2 1 2 2 2 1);
my $length          = 8;
my $direction       = 1;
my $in_reverse      = 0;
my $relative        = 0;

GetOptions(
  'direction=i' => \$direction,
  'flats'       => \my $use_flats,
  'help|h|?'    => \&print_help,
  'intervals=s' => \my $intervals,
  'relative'    => \$relative,
  'length=i'    => \$length,
  'raw'         => \my $raw_output,
  'reverse'     => \$in_reverse,
);

my $start_note = lc(shift) || 'c';
if ( !exists $note2num{$start_note} ) {
  warn "error: unknown start note: '$start_note'\n";
  print_help();
}

$direction = int($direction);
die "error: a direction of zero is a bit too aimless\n" if $direction == 0;
$length = int($length);
die "error: length must be at least one\n" if $length < 1;

@scale_intervals = names2intervalset( map lc, split /[\s,]+/, $intervals )
  if defined $intervals;

$num2note_flavor .= $use_flats ? 'flat' : 'sharp';

########################################################################
#
# MAIN

@scale_intervals = reverse @scale_intervals if $in_reverse;

my $pitch      = $note2num{$start_note};
my $prev_pitch = $pitch;
for my $i ( 0 .. $length - 1 ) {
  if ($raw_output) {
    print $pitch;
  } else {
    my $ly_reg = "";
    if ( !$relative and $i > 0 ) {
      if ( $pitch < 0 ) {
        $ly_reg =
          q{,} x ( ( abs($pitch) + $DEG_IN_SCALE - 1 ) / $DEG_IN_SCALE );
      } elsif ( $pitch >= $DEG_IN_SCALE ) {
        $ly_reg = q{'} x ( $pitch / $DEG_IN_SCALE );
      }
    }

    print $num2note{$num2note_flavor}->{ $pitch % $DEG_IN_SCALE } . $ly_reg;
  }
  print " " if $i < $length - 1;

  $prev_pitch = $pitch;
  $pitch += $scale_intervals[ $i % @scale_intervals ] * $direction;
}
print "\n";

exit 0;

########################################################################
#
# SUBROUTINES

# Convert between intput of 'c cis dis e g' to numeric interval set, so
# user can input arbitrary scales using note names. (Mixing note names
# and interval numbers is not supported.)
sub names2intervalset {
  my @input = @_;
  my @iset;
  my $is_conversion = 0;

  my $prev_pitch;
  for my $i ( 0 .. $#input ) {
    if ( $input[$i] !~ m/^-?\d+$/ ) {
      if ( !exists $note2num{ $input[$i] } ) {
        warn "error: unknown note: '$input[$i]'\n";
        print_help();
      }
      $is_conversion = 1;
      push @iset, $note2num{ $input[$i] } - $prev_pitch if $i > 0;
      $prev_pitch = $note2num{ $input[$i] };
    }
  }

  @iset = @input unless $is_conversion;
  return @iset;
}

sub print_help {
  my @startnotes = sort { $note2num{$a} <=> $note2num{$b} } keys %note2num;
  my $sc = wrap( '  ', '', @startnotes );

  warn <<"END_HELP";
Usage: $0 [options] startnote

Possible starting notes:
$sc

Options affecting input:
  --direction       Positive, scale goes up, negative, down. Magnitudes
                    greater than one multiply the interval, though this
                    behavior may be subject to change in the future.
  --intervals       List of intervals or notes of the scale.
  --length          How many notes to generate in output.
  --reverse         Reverses order of intervals.

Options affecting output:
  --flats           Use flats in output, instead of default sharps.
  --raw             Emit pitch numbers instead of note names.
  --relative        Use relative lilypond output (default: absolute).

END_HELP
  exit 64;
}

END {
  # Report problems when writing to stdout (perldoc perlopentut)
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
