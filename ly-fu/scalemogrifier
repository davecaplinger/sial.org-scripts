#!/usr/bin/perl
#
# Generate notes of a scale (a subset of the Western 12-tone chromatic
# system) from a specified starting note in a specified direction and so
# forth from other options. Default is The Major Scale, but that's easy
# to adjust:
#
#   $ scalemogrifier --intervals='c d ees f g aes bes' --flats fis
#
# Or to more exotic territory:
#
#   $ scalemogrifier --intervals='c cis dis e g' --length=12 f
#
# Or backwards:
#
#   $ scalemogrifier --dir=-1 --intervals='c cis dis e g' --length=12 f
#
# Or backwards with the interval order reversed:
#
#   $ scalemogrifier --rev --dir=-1 --intervals='c cis dis e g' --length=12 f
#
# Or just plain made up with raw pitch numbers:
#
#   $ scalemogrifier --intervals=1,2,3,4 --raw --len=24
#
# Or output not really a scale at all:
#
#   $ scalemogrifier --intervals=1,2,3,5,7 --dir=53 --relative --len=24
#
# Or even sequences, such as down a 4th and up a 5th:
#
#   $ scalemogrifier --intervals=-5,7 --len=24 c
#
# Practical application of the results to music theory or composition
# left as an exercise to the user. The output could be fed to `ly-fu --abs`
# for playback or incorporation into a lilypond document.
#
# Consider http://oeis.org/ to lookup or find interesting interval sets;
# for example, search for the major interval sequence for numeric
# sequences that contain it:
#
# http://oeis.org/search?q=2,2,1,2,2,2,1

# TODO --ois plus custom startnote is buggy

use strict;
use warnings;

use Getopt::Long qw/GetOptions/;
use List::Util qw/sum/;
use Text::Wrap qw/wrap/;

# Accepted note names to pitch number for user input
my %note2num = qw(c 0 cis 1 d 2 dis 3 e 4 f 5 fis 6 g 7 gis 8 a 9 ais 10 b 11
  ces 11 des 1 ees 3 fes 4 ges 6 aes 8 bes 10 eis 5 bis 0);

# Note names for program output
my %num2note = (
  'ly-sharp' =>
    {qw/0 c 1 cis 2 d 3 dis 4 e 5 f 6 fis 7 g 8 gis 9 a 10 ais 11 b/},
  'ly-flat' =>
    {qw/0 c 1 des 2 d 3 ees 4 e 5 f 6 ges 7 g 8 aes 9 a 10 bes 11 b/},
);
my $num2note_flavor = 'ly-';

# Not The Scale, but to map back to That Other Scale.
my $DEG_IN_SCALE = 12;

my @scale_intervals = qw(2 2 1 2 2 2 1);
my $length          = 8;
my $direction       = 1;
my $in_reverse      = 0;
my $relative        = 0;

my $output_delimiter = " ";
my ( @output_intervals, $output_sum );

########################################################################
#
# MAIN

GetOptions(
  'direction=i'            => \$direction,
  'flats'                  => \my $use_flats,
  'help|h|?'               => \&print_help,
  'intervals=s'            => \my $intervals,
  'ors=s'                  => \$output_delimiter,
  'output_intervals|ois=s' => \my $output_intervals,
  'relative'               => \$relative,
  'length=i'               => \$length,
  'raw'                    => \my $raw_output,
  'reverse'                => \$in_reverse,
) || die "error: could not parse options\n";

my $start_note = lc(shift) || 'c';
if ( !exists $note2num{$start_note} ) {
  warn "error: unknown start note: '$start_note'\n";
  print_help();
}

$direction = int($direction);
die "error: a direction of zero is a bit too aimless\n" if $direction == 0;
$length = int($length);
die "error: length must be at least one\n" if $length < 1;

@scale_intervals = names2intervalset( map lc, split /[\s,]+/, $intervals )
  if defined $intervals;

if ( defined $output_intervals ) {
  my @output_args = map lc, split /[\s,]+/, $output_intervals;
  @output_intervals = names2intervalset(@output_args);
  $output_sum       = sum @output_intervals;
}
$output_delimiter =~ s/(\\.)/qq!"$1"!/eeg;

$num2note_flavor .= $use_flats ? 'flat' : 'sharp';

@scale_intervals = reverse @scale_intervals if $in_reverse;

my $pitch      = $note2num{$start_note};
my $prev_pitch = $pitch;

for my $i ( 0 .. $length - 1 ) {
  if ( !$raw_output ) {
    my $output_pitch     = $pitch;
    my $normalized_pitch = $output_pitch % $DEG_IN_SCALE;
    my $ly_reg           = "";

    if (@output_intervals) {
      my $pitch_reg = int( $output_pitch / @output_intervals );    # XXX buggy
      my $pitch_mod = $output_pitch % @output_intervals - 1;

      $output_pitch = $pitch_reg * $output_sum +
        ( $pitch_mod >= 0 ? sum( @output_intervals[ 0 .. $pitch_mod ] ) : 0 );
      $normalized_pitch = $output_pitch % $DEG_IN_SCALE;
    }

    if ( !$relative and $i > 0 ) {
      if ( $output_pitch < 0 ) {
        $ly_reg = q{,} x
          ( ( abs($output_pitch) + $DEG_IN_SCALE - 1 ) / $DEG_IN_SCALE );
      } elsif ( $output_pitch >= $DEG_IN_SCALE ) {
        $ly_reg = q{'} x ( $output_pitch / $DEG_IN_SCALE );
      }
    }

    print $num2note{$num2note_flavor}->{$normalized_pitch}, $ly_reg;
  } else {
    print $pitch;
  }
  print $output_delimiter if $i < $length - 1;

  $prev_pitch = $pitch;
  $pitch += $scale_intervals[ $i % @scale_intervals ] * $direction;
}
print "\n";

exit 0;

########################################################################
#
# SUBROUTINES

# Convert between intput of 'c cis dis e g' to numeric interval set, so
# user can input arbitrary scales using note names. (Mixing note names
# and interval numbers is not supported.)
sub names2intervalset {
  my @input = @_;
  my @iset;
  my $is_conversion = 0;

  my $prev_pitch;
  # NOTE , 0 addition to loop is to complete the scale back to the
  # starting note
  for my $i ( 0 .. $#input, 0 ) {
    if ( $input[$i] !~ m/^-?\d+$/ ) {
      if ( !exists $note2num{ $input[$i] } ) {
        warn "error: unknown note: '$input[$i]'\n";
        print_help();
      }
      $is_conversion = 1;
      if ( defined $prev_pitch ) {
        my $delta = $note2num{ $input[$i] } - $prev_pitch;
        if ( abs($delta) > $DEG_IN_SCALE / 2 ) {
          $delta = ( $DEG_IN_SCALE - abs($delta) ) * ( $delta > 0 ? -1 : 1 );
        }
        push @iset, $delta;
      }
      $prev_pitch = $note2num{ $input[$i] };
    }
  }

  @iset = @input unless $is_conversion;
  return @iset;
}

sub print_help {
  my @startnotes = sort { $note2num{$a} <=> $note2num{$b} } keys %note2num;
  my $sc = wrap( '  ', '', @startnotes );

  warn <<"END_HELP";
Usage: $0 [options] startnote

Possible starting notes:
$sc

Options affecting input:
  --direction       Positive, scale goes up, negative, down. Magnitudes
                    greater than one multiply the interval, though this
                    behavior may be subject to change in the future.
  --intervals       List of intervals or notes of the scale.
  --length          How many notes to generate in output.
  --reverse         Reverses order of intervals.

Options affecting output:
  --flats           Use flats in output, instead of default sharps.
  --ois             Custom scale or interval set output will be mapped into.
  --ors             What will be printed between output elements.
                    Defaults to the space character.
  --raw             Emit pitch numbers instead of note names.
  --relative        Generate relative lilypond output (default: absolute).

END_HELP
  exit 64;
}

END {
  # Report problems when writing to stdout (perldoc perlopentut)
  unless ( close(STDOUT) ) {
    warn "error: problem closing STDOUT: $!\n";
    exit 74;
  }
}
